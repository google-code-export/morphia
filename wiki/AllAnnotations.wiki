#summary All the supported annotations
#labels Featured
<wiki:toc>

= Annotations =

Below is a list of all the annotations and a brief descriptions of how to use them.

Note: In java the default attribute for an annotations can be used without a name. The name of the default attribute is always *value*. Any time you see {{{@MyAnnotation("arg")}}} it can be re-written as {{{@MyAnnotation(valeu = "arg")}}}, and must be if you add additional attributes.  
  
== Entity ==
Marks entities to be stored directly in a collection. Look [EntityAnnotation here] for more examples.

This annotations is optional in most cases. There is no harm in including it to be more verbose, and make clear the intention for the class.

=== Collection Name ==
Attribute name: *value*

{{{@Entity("name")}}}

=== Capped ===
Attribute name: *cap*

{{{@Entity(cap = @CappedAt(...))}}}

=== Do not store classname ===
Attribute name: *noClassnameStored*

{{{@Entity(noClassnameStored = true)}}}

This attribute is temporary until polymorphism is completed.

== Indexes ==

In addition to being able to declare an index on a single field you can also declare the indexes at the class level. This allows you to create more than just a single field index; it allows you to create compound indexes with multiple fields.

=== Compound Indexes ===
Compound indexes are indexes that include several fields, in a specific order. They are annotated on the the class itself since they include multiple fields. As an example imagine you have a collection that stores changes made by a user. If you want to be able to quickly query recent changes for a given user, you would want to create an index containing both user and date; the order of the fields is significant so please read up on the mongo side of things for optimal performance.

{{{
@Entity // this is require to know where the indexes are to be created
@Indexes( @Index("user, -date")
public class ChangeLog{
 Date date;
 String user;
 Record changedRecord;
} 

}}}

The minus on "-date" indicates that the field is indexed in descending order making it quicker to sort from most recent to oldest. This is the same syntax used when sorting or ordering results from a query.

Say you decided you also needed to be able to quickly find recent changes for the record being changed. You could change the annotation to:
{{{
@Indexes({
   @Index("user, -cs"),
   @Index("changedRecord, -cs")})
}}}

And now you will have two compound indexes on that collection.

If you like you can also define single field indexes in this fashion as well; it is recommended that you don't since it is more error prone.


== Id ==
Marks a field in an {{{@Entity}}} to be the "_id" field in mongodb.

{{{
@Entity
class Myclass {
   @Id ObjectId id = new ObjectId();
   ...
}
}}}

== Transient ==
The field with not be persisted.

== Serialized ==
The field with be converted to binary, and persisted.

== {{{NotSaved}}} ==
The field will not be saved, but can be loaded. Good for data migration.

== {{{AlsoLoad}}} ==
The field will can be loaded as any of the supplied names. Good for data migration.

== Indexed ==
The field will be indexed. See [Datastore the datastore docs].

== Version ==
Marks a field in an {{{@Entity}}} to be control optimistic locking for that entity. It will be automatically managed for you. There is no need to set a value.

{{{
@Entity
class Myclass {
   ...
   @Version Long v;
}
}}}

== Reference ==
Marks fields as stored in another collection and which are linked (by a dbref reference field). When the Entity is loaded, so is the (direct) reference. 


Attribute name: *lazy*
Instead of loading the referenced field with the Entity, it will be lazily loaded on the first method call of the proxy instance.

Look [ReferenceAnnotation here] for more examples.

== Embedded ==
Allows customization of certain options. Look [EmbeddedAnnotation here] for more examples.

== Lifecycle Annotations ==
See the this [LifecycleMethods page].