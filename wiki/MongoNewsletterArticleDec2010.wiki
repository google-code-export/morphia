#summary The morphia related article for the Dec 2010 MongoDB Newsletter

= Be optimistic on your updates, but too much =

There are many ways to manage [http://en.wikipedia.org/wiki/Concurrency_control concurrency controls] for MongoDB. One way that [http://code.google.com/p/morphia Morphia] does this is by supplying a special annotation, {{{@Version}}}. [http://code.google.com/p/morphia Morphia] is a lightweight, type safe, and type preserving, java-based mapper for MongoDB; in simple terms it allows you to save java object to and from mongodb without writing much code. The [http://code.google.com/p/morphia Morphia] {{{@Version}}} annotation is used to provide optimistic locking when updating an Entity; this makes sure that changes made by multiple clients don't stomp on each other -- at least not without generating an error. 

This type of concurrency control will let anyone read the entity, but will check when writes occur that no one has updated between your read and update. To do this you just need a special field on the entity; we can increment this field as each update happens to provide these assurances. This concurrency model helps when you update a single entity at a time, but not for multiple updates.

There are also pessimistic (locking) models where an explicit lock can be acquired before, or during, the update process. These generally perform more poorly, have a higher management cost, and are more complicated to implement, but they have many benefits as well. I will not address these and I will continue to talk about optimistic and/or time-stamp based algorithms.

Now let's dive into the actual code. In the code, and descriptions, below you can replace the word *entity* with *document* if you like. I will be speaking in Java terms.

== The Entity Definition (model) ==
{{{

class Person {
  @Id String name;
  String phone;

  @Version
  long version;
...
}
}}}

== The Plan ==
Now that we have our class properly mocked up, and annotated, we can start to create some test instances and check things out. The goal of this test is to show that with a single line of code in our entity (model) we can make sure that nobody accidentally saves over something that has already been updated.   

=== Setup ===
Now we create our [http://code.google.com/p/morphia/wiki/Datastore Datastore] which will used to access mongodb. We then create a {{{new Person(...)}}} and save me.

{{{
Datastore ds = ...;

Person me = new Person("Scott Hernandez");

ds.save(me) // all good
}}}

After the {{{save(...)}}} has completed our person now has a value stored in the {{{@Version}}} field which will be used by [http://code.google.com/p/morphia Morphia] to manage things for us. If you look you will see that by default it is a counter set to the current milliseconds, but it could be a mono-atomically increasing number as well.

=== Handling The Error ===

{{{
Person meAgain = ds.get(Person.class, "Scott Hernandez");

me.setPhone("111-376-7379"); 
ds.save(me); // now "me" and "meAgain" are different versions

try {
  ds.setPhone("123-376-7379");
  ds.save(meAgain);
} catch (ConcurrentModificationException e) {
  // ooppsss... someone modified it since we got it.
  // try again, but this time get the new version to work from... or notify the user.
}
}}}

Now that we have created two instances of the same person, and updated them one at a time, we can cause a {{{ConcurrentModificationException}}} to be thrown. You can imagine that this might happens on different threads or machines.

== Under the Covers ==

Deep, well not so deep, in the Morphia persistence code is a check to see if there is a {{{@Version}}} field in the entity. If so, then the value is added to the list of fields used to do the query part of the update. Normally when you do a save it will just do an update based on the {{{_id}}} field.

Here is the "save" javascript from the shell:
{{{
> db.c.save
function (obj) {
... //insert or
    return this.update({_id:obj._id}, obj, true);
}
}}}

To support the new version field we simply add it to the query on the update. In addition we must increment the version to a new one. This pseudo-code might give you the simple idea:

{{{
var oldVersion = obj.version;
obj.version = newVersion;
...update({_id:obj._id, version:obj.version}, obj);
}}}

== Wrap-up ==

Using {{{@Version}}} is trivial in Morphia. It provides additional concurrency control from what MongoDB offers without costing anything but a little extra space per Entity and very tiny bit of extra work on matching/updating. This type of optimistic locking pattern is very easy for any framework to implement and solves many problems that read-world developers have. Some frameworks not only support optimistic, but also a form of pessimistic locking; you can create an external document, a lock basically, to indicate that the update is in process for some other document, like the [http://www.doctrine-project.org/projects/mongodb_odm/1.0/docs/reference/introduction/en Doctrine PHP ODM] framework does. I'm sure that many mappers -- which include Morphia, Doctrine and MongoKit, and more -- have implemented optimistic concurrency controls like this.