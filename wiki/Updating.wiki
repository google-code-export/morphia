#summary How to update data

<wiki:toc/>

= Introduction =

There are two basic ways to update your data. You can either insert/save a whole Entity, or issue an update operation. We will be talking about the latter below.

= Updating (on the server) =

When you call the update method on the [Datastore] you are issuing a command to the server to change existing data, in general.

[http://www.mongodb.org/display/DOCS/Updating MongoDB Docs on Updating]

{{{
interface Datastore {
...

	/** updates all entities found with the operations*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops);
	/** updates all entities found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, T entity, boolean createIfMissing);
}

interface UpdateOperations<T> {
	//Affect a single field/value
	UpdateOperations<T> set(String fieldExpr, Object value);
	UpdateOperations<T> unset(String fieldExpr);

	UpdateOperations<T> dec(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr, Number value);

	//Affect an array/list of values
	UpdateOperations<T> add(String fieldExpr, Object value);
	UpdateOperations<T> add(String fieldExpr, Object value, boolean addDups);
	UpdateOperations<T> addAll(String fieldExpr, List<?> values, boolean addDups);
	
	UpdateOperations<T> removeFirst(String fieldExpr);
	UpdateOperations<T> removeLast(String fieldExpr);
	UpdateOperations<T> removeAll(String fieldExpr, Object value);
	UpdateOperations<T> removeAll(String fieldExpr, List<?> values);
}

}}}

== Samples initialization ==

All of the code samples below create the connection and morphia instance using the following code:

{{{
Morphia morphia = new Morphia();
morphia.map(Hotel.class).map(Address.class);
Datastore datastore = morphia.createDatastore("MorphiaSampleDb");
Hotel hotel = new Hotel("Fairmont", 3, new Address("1 Rideau Street", "Ottawa", "K1N8S7", "Canada"));
datastore.save(hotel);
UpdateOperations<Hotel> ops;

// This query will be used in the samples to restrict the update operations to only the hotel we just created.
// We could use any field here but _id will be unique and mongodb by default puts an index on the _id field so this should be fast!
Query<Hotel> updateQuery = datastore.createQuery(Hotel.class).field("_id").equal(hotel.getId());

// The Mapper class also provides a public static of the default _id field name for us...
Query<Hotel> updateQuery = datastore.createQuery(Hotel.class).field(Mapper.ID_KEY).equal(hotel.getId());

@Entity("hotels")
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   @Embedded
   List<Integer> roomNumbers = new ArrayList<Integer>();

   // ... getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... getters and setters
}
}}}

== set/unset ==

{{{
// change the name of the hotel
ops = datastore.createUpdateOperations(Hotel.class).set("name", "Fairmont Chateau Laurier");
datastore.update(updateQuery, ops);

// also works for embedded documents, change the name of the city in the address
ops = datastore.createUpdateOperations(Hotel.class).set("address.city", "Ottawa");
datastore.update(updateQuery, ops);

// remove the name property from the document
// causes the next load of the Hotel to have name = null
ops = datastore.createUpdateOperations(Hotel.class).unset("name");
datastore.update(updateQuery, ops);
}}}

== inc/dec ==
{{{
// increment 'stars' by 1
ops = datastore.createUpdateOperations(Hotel.class).inc("stars");
datastore.update(updateQuery, ops);

// increment 'stars' by 4
ops = datastore.createUpdateOperations(Hotel.class).inc("stars", 4);
datastore.update(updateQuery, ops);

// decrement 'stars' by 1
ops = datastore.createUpdateOperations(Hotel.class).dec("stars");  // same as .inc("stars", -1)
datastore.update(updateQuery, ops);

// decrement 'stars' by 4
ops = datastore.createUpdateOperations(Hotel.class).inc("stars", -4);
datastore.update(updateQuery, ops);
}}}

== add/All ==
{{{

// default behavior for add() is to act like set()
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11);  // same as .set("roomNumbers", 11)
datastore.update(updateQuery, ops);

}}}

The above operation acts like a set() which just creates the property and sets its value.

Performing array operations on a non-array property causes mongodb to throw an error.  We'll see that in the next sample.

{{{

// causes error since 'roomNumbers' is not an array at this point
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11, false);
datastore.update(updateQuery, ops);  // causes error

// delete the property
ops = datastore.createUpdateOperations(Hotel.class).unset("roomNumbers");
datastore.update(updateQuery, ops);

// 3rd parameter to add duplicates which makes the operation work with arrays

// this time add and create it as an array
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11, false);
datastore.update(updateQuery, ops);  // [ 11 ]

// no change since its a duplicate... doesn't cause error
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11, false);
datastore.update(updateQuery, ops);  // [ 11 ]

// push onto the end of the array
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 12, false);
datastore.update(updateQuery, ops); // [ 11, 12 ]

// add even if its a duplicate
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11, false);
datastore.update(updateQuery, ops); // [ 11, 12, 11 ]
}}}

== removeFirst/Last/All ==
{{{
//example
}}}

== multiple upOps ==
{{{
//example
}}}

== updateFirst method ==

In the default driver and shell this is the default behavior. In Morphia we feel like updating all the results of the query is a better default (see below).

{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}

== update method ==
{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}