#summary How to update data

<wiki:toc/>

= Introduction =

There are two basic ways to update your data. You can either insert/save a whole Entity, or issue an update operation. We will be talking about the latter below.

= Updating (on the server) =

When you call the update method on the [Datastore] you are issuing a command to the server to change existing data, in general.

[http://www.mongodb.org/display/DOCS/Updating MongoDB Docs on Updating]

{{{
interface Datastore {
...

	/** updates all entities found with the operations*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops);
	/** updates all entities found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, T entity, boolean createIfMissing);
}

interface UpdateOperations<T> {
	//Affect a single field/value
	UpdateOperations<T> set(String fieldExpr, Object value);
	UpdateOperations<T> unset(String fieldExpr);

	UpdateOperations<T> dec(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr, Number value);

	//Affect an array/list of values
	UpdateOperations<T> add(String fieldExpr, Object value);
	UpdateOperations<T> add(String fieldExpr, Object value, boolean addDups);
	UpdateOperations<T> addAll(String fieldExpr, List<?> values, boolean addDups);
	
	UpdateOperations<T> removeFirst(String fieldExpr);
	UpdateOperations<T> removeLast(String fieldExpr);
	UpdateOperations<T> removeAll(String fieldExpr, Object value);
	UpdateOperations<T> removeAll(String fieldExpr, List<?> values);
}

}}}

== Samples initialization ==

All of the code samples below create the connection and morphia instance using the following code:

{{{
Morphia morphia = new Morphia();
morphia.map(Hotel.class).map(Address.class);
Datastore datastore = morphia.createDatastore("MorphiaSampleDb");
Hotel hotel = new Hotel("Fairmont", 3, new Address("1 Rideau Street", "Ottawa", "K1N8S7", "Canada"));
datastore.save(hotel);

// This query will be used in the samples to restrict the update operations to only the hotel we just created.
// We could use any field here but _id will be unique and mongodb by default puts an index on the _id field so this should be fast!
Query<Hotel> updateQuery = datastore.createQuery(Hotel.class).field("_id").equal(hotel.getId());

// The Mapper class also provides a public static of the default _id field name for us...
updateQuery = datastore.createQuery(Hotel.class).field(Mapper.ID_KEY).equal(hotel.getId());



@Entity("hotels")
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   // ... getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... getters and setters
}
}}}

== set/unset ==

{{{
UpdateOperations<Hotel> setOps;

// change the name of the hotel
setOps = datastore.createUpdateOperations(Hotel.class).set("name", "Fairmont Chateau Laurier");
datastore.update(updateQuery, setOps);

// this works for embedded documents, change the name of the city in the address
setOps = datastore.createUpdateOperations(Hotel.class).set("address.city", "Ottawa");
datastore.update(updateQuery, setOps);

// remove the name property from the document
// causes the next load of the Hotel to have name = null
setOps = datastore.createUpdateOperations(Hotel.class).unset("name");
datastore.update(updateQuery, setOps);

}}}

== inc/dec ==
{{{
// increment 'stars' by 1
setOps = datastore.createUpdateOperations(Hotel.class).inc("stars");
datastore.update(updateQuery, setOps);

// increment 'stars' by 4
setOps = datastore.createUpdateOperations(Hotel.class).inc("stars", 4);
datastore.update(updateQuery, setOps);

// decrement 'stars' by 1
setOps = datastore.createUpdateOperations(Hotel.class).dec("stars");
datastore.update(updateQuery, setOps);
}}}

== add/All ==
{{{
//example
}}}

== removeFirst/Last/All ==
{{{
//example
}}}

== multiple upOps ==
{{{
//example
}}}

== updateFirst method ==

In the default driver and shell this is the default behavior. In Morphia we feel like updating all the results of the query is a better default (see below).

{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}

== update method ==
{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}