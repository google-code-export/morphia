#summary How to update data

<wiki:toc/>

= Introduction =

There are two basic ways to update your data. You can either insert/save a whole Entity, or issue an update operation. We will be talking about the latter below.

= Updating (on the server) =

When you call the update method on the [Datastore] you are issuing a command to the server to change existing data, in general.

[http://www.mongodb.org/display/DOCS/Updating MongoDB Docs on Updating]

{{{
interface Datastore {
...

	/** updates all entities found with the operations*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops);
	/** updates all entities found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> update(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, UpdateOperations<T> ops, boolean createIfMissing);
	/** updates the first entity found with the operations; if nothing is found insert the update as an entity if "createIfMissing" is true*/
	<T> UpdateResults<T> updateFirst(Query<T> query, T entity, boolean createIfMissing);
}

interface UpdateOperations<T> {
	//Affect a single field/value
	UpdateOperations<T> set(String fieldExpr, Object value);
	UpdateOperations<T> unset(String fieldExpr);

	UpdateOperations<T> dec(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr);
	UpdateOperations<T> inc(String fieldExpr, Number value);

	//Affect an array/list of values
	UpdateOperations<T> add(String fieldExpr, Object value);
	UpdateOperations<T> add(String fieldExpr, Object value, boolean addDups);
	UpdateOperations<T> addAll(String fieldExpr, List<?> values, boolean addDups);
	
	UpdateOperations<T> removeFirst(String fieldExpr);
	UpdateOperations<T> removeLast(String fieldExpr);
	UpdateOperations<T> removeAll(String fieldExpr, Object value);
	UpdateOperations<T> removeAll(String fieldExpr, List<?> values);
}

}}}

== Samples initialization ==

All of the code samples below create the connection and morphia instance using the following code:

{{{
Morphia morphia = new Morphia();
morphia.map(Hotel.class).map(Address.class);
Datastore datastore = morphia.createDatastore("MorphiaSampleDb");
Hotel hotel = new Hotel("Fairmont", 3, new Address("1 Rideau Street", "Ottawa", "K1N8S7", "Canada"));
datastore.save(hotel);
UpdateOperations<Hotel> ops;

// This query will be used in the samples to restrict the update operations to only the hotel we just created.
// We could use any field here but _id will be unique and mongodb by default puts an index on the _id field so this should be fast!
Query<Hotel> updateQuery = datastore.createQuery(Hotel.class).field("_id").equal(hotel.getId());

// The Mapper class also provides a public static of the default _id field name for us...
Query<Hotel> updateQuery = datastore.createQuery(Hotel.class).field(Mapper.ID_KEY).equal(hotel.getId());

@Entity("hotels")
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   @Embedded
   List<Integer> roomNumbers = new ArrayList<Integer>();

   // ... getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... getters and setters
}
}}}

== set/unset ==

{{{
// change the name of the hotel
ops = datastore.createUpdateOperations(Hotel.class).set("name", "Fairmont Chateau Laurier");
datastore.update(updateQuery, ops);

// also works for embedded documents, change the name of the city in the address
ops = datastore.createUpdateOperations(Hotel.class).set("address.city", "Ottawa");
datastore.update(updateQuery, ops);

// remove the name property from the document
// causes the next load of the Hotel to have name = null
ops = datastore.createUpdateOperations(Hotel.class).unset("name");
datastore.update(updateQuery, ops);

}}}

== inc/dec ==
{{{
// increment 'stars' by 1
ops = datastore.createUpdateOperations(Hotel.class).inc("stars");
datastore.update(updateQuery, ops);

// increment 'stars' by 4
ops = datastore.createUpdateOperations(Hotel.class).inc("stars", 4);
datastore.update(updateQuery, ops);

// decrement 'stars' by 1
ops = datastore.createUpdateOperations(Hotel.class).dec("stars");  // same as .inc("stars", -1)
datastore.update(updateQuery, ops);

// decrement 'stars' by 4
ops = datastore.createUpdateOperations(Hotel.class).inc("stars", -4);
datastore.update(updateQuery, ops);
}}}

== add/All ==
{{{
// default behavior for add() is to act like set()
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11);
datastore.update(updateQuery, ops);  // same as .set("roomNumbers", 11)

ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 12, false);
datastore.update(updateQuery, ops);  // same as .set("roomNumbers", 12)

// to make add() act like a $push, use 3rd parameter to include dups
ops = datastore.createUpdateOperations(Hotel.class).add("roomNumbers", 11, true);
datastore.update(updateQuery, ops);  // append 11 to array

}}}

== removeFirst/Last/All ==
{{{
//example
}}}

== multiple upOps ==
{{{
//example
}}}

== updateFirst method ==

In the default driver and shell this is the default behavior. In Morphia we feel like updating all the results of the query is a better default (see below).

{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}

== update method ==
{{{
//example
}}}
{{{
//shell version
}}}

=== createIfMissing ===
{{{
//example
}}}
{{{
//shell version
}}}